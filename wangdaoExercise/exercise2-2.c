#include<stdio.h>
#include<stdlib.h>
#include <stdbool.h>
#include "linkedList.h"
//设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点
bool deleteX(ListPointer l,ElemType X){
    if(l->next!=NULL){
        
        ListPointer p = l;
        
    }
    
}

//在带头结点的单链表L中，删除所有值为X的结点，并释放其空间，假设值为X的结点不唯一，试编写算法实现以上的操作
bool deleteX(ListPointer l,ElemType X){
    if(l->next!=NULL){
        
        ListPointer p = l;
        if(l->data == X){
            free(p);
            l = l->next
        }else{
            l=l->next;
        }


    }
    
}
//设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值

//试编写算法将带头结点的单链表就地逆置，指辅助空间复杂度为O(1)
//试编写算法将带头结点的单链表L中删除一个最小值结点的高效算法
//有一个带头结点的单链表L，设计一个算法使其元素递增有序
//设在一个带表头结点的单链表中所有的元素结点都无序，试编写一个函数删除表中所有介于给定两个之间的元素的元素
//给定两个单链表，编写算法找出两个链表的公共结点
/*给定一个带表头结点的单链表，设head为头指针，结点结构为(data,next)，data为整形元素，next为指针，
试写出算法：按照递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许舒勇数组作为辅助空间）*/
//将一个带头结点的单链表A分解为两个带头结点的单链表A和B使得A表中含有原表中序号为基数的元素，而B表中含有原表中序号为偶数的元素，且保持相对顺序不变
//设C={a1,b1,a2,b2,…,an,bn}为线性表采用带头结点的hc单链表存放设计一个算法将其拆分为两个为两个线性表使得A={a1,a2,a3…,an},B={b1,b2,b3…bn}.
//在一个递增有序的线性表中，有数值相同的元素存在。若存储的方式为单链表，设计算法去掉数值相同的元素使表中不再有重复元素
//假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表
//设A和B是两个带头结点的单链表，其中元素递增有序。设计一个算法从A和B中的公共元素产生链表C，要求不破坏A，B的结点。
//已知两个链表A，B分别表示两个集合，其元素递增排序，编制函数求A，B的交集，并存放于A链表中